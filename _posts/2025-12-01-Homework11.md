---
layout: post
title: Homework 11 - Simulating and Analyzing Brownian Motion
use_math: true
date: 2025-12-01
---

<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    .dashboard-container {
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        margin-top: 20px;
    }

    /* Input Grid Styling */
    .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        margin-bottom: 20px;
    }
    
    .control-group label {
        display: block;
        font-weight: 600;
        margin-bottom: 5px;
        font-size: 0.9em;
        color: #495057;
    }
    
    .control-group input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 1em;
    }

    /* Action Button */
    .btn-run {
        width: 100%;
        padding: 12px;
        background-color: #e67e22; /* Burnt Orange */
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 1.1rem;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-bottom: 20px;
    }
    
    .btn-run:hover {
        background-color: #d35400;
    }

    /* Statistics Display Box */
    .stats-panel {
        background-color: #2c3e50; /* Dark Slate */
        color: #ecf0f1;
        padding: 20px;
        border-radius: 8px;
        font-family: 'Courier New', Courier, monospace;
        line-height: 1.5;
        margin-bottom: 30px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .stats-panel h4 {
        margin-top: 0;
        color: #3498db;
        border-bottom: 1px solid #465c70;
        padding-bottom: 10px;
        margin-bottom: 15px;
    }

    /* Charts Area */
    .charts-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }
    
    .chart-box {
        flex: 1;
        min-width: 350px;
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
</style>

## 1. Theoretical Background

In this assignment, we simulate and analyze **Brownian Motion** (or the Wiener Process). A standard Brownian motion $W_t$ is a continuous-time stochastic process with the following properties:

1.  **Start at Zero:** $W_0 = 0$.
2.  **Independent Increments:** The future change $W_{t+u} - W_t$ is independent of the past.
3.  **Gaussian Increments:** $W_t - W_s \sim \mathcal{N}(0, t-s)$ for $0 \le s < t$.

To simulate this numerically, we discretize time into $n$ steps of size $dt = T/n$. The change in position at each step is given by:
$$
dW_t = \sigma \cdot \varepsilon \sqrt{dt}
$$
Where $\varepsilon \sim \mathcal{N}(0, 1)$ is a standard normal random variable and $\sigma$ is the diffusion coefficient (volatility).

The theoretical moments for the process at time $T$ are:
$$
E[W_T] = 0 \quad \text{and} \quad Var(W_T) = \sigma^2 T
$$

---

## 2. Interactive Simulator

Use the controls below to generate sample paths and verify the statistical properties dynamically.

<div class="dashboard-container">

    <div class="controls-grid">
        <div class="control-group">
            <label>1. Time Horizon (T)</label>
            <input type="number" id="inp_T" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>2. Time Steps (n)</label>
            <input type="number" id="inp_n" value="1000" step="100">
        </div>
        <div class="control-group">
            <label>3. Trajectories (N)</label>
            <input type="number" id="inp_N" value="500" step="50">
        </div>
        <div class="control-group">
            <label>4. Diffusion ($\sigma$)</label>
            <input type="number" id="inp_sigma" value="1" step="0.1">
        </div>
    </div>

    <button class="btn-run" onclick="runBrownianSimulation()">Run Simulation</button>

    <div class="stats-panel" id="statsOutput">
        <em>Press "Run Simulation" to generate statistics.</em>
    </div>

    <div class="charts-container">
        <div class="chart-box">
            <canvas id="pathChart"></canvas>
        </div>
        <div class="chart-box">
            <canvas id="histChart"></canvas>
        </div>
    </div>

</div>

<script>
// Global Chart Instances
let pathChartInstance = null;
let histChartInstance = null;

// Box-Muller Transform for Standard Normal Random Numbers
function randn_bm() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random(); 
    while(v === 0) v = Math.random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}

function runBrownianSimulation() {
    // 1. Gather Inputs
    const T = parseFloat(document.getElementById('inp_T').value);
    const n = parseInt(document.getElementById('inp_n').value);
    const numPaths = parseInt(document.getElementById('inp_N').value);
    const sigma = parseFloat(document.getElementById('inp_sigma').value);
    
    const dt = T / n;
    
    // 2. Data Arrays
    const allFinalPositions = []; // To store W(T) for every path
    const pathDatasets = [];      // For Chart.js
    const maxPathsToDraw = 50;    // Limit drawing to 50 paths for performance
    
    // Generate X-axis labels (Time)
    // To save memory, we only generate labels for drawn points
    const timeLabels = [];
    for(let i=0; i<=n; i++) {
        timeLabels.push((i * dt).toFixed(2));
    }

    // 3. Simulation Loop
    for (let p = 0; p < numPaths; p++) {
        let currentW = 0;
        const currentPath = [0]; // Start at 0

        for (let i = 0; i < n; i++) {
            const dW = sigma * Math.sqrt(dt) * randn_bm();
            currentW += dW;
            
            // Only save full path history if we are going to draw it
            if (p < maxPathsToDraw) {
                currentPath.push(currentW);
            }
        }

        allFinalPositions.push(currentW);

        // Add to datasets if within draw limit
        if (p < maxPathsToDraw) {
            pathDatasets.push({
                label: `Path ${p}`,
                data: currentPath,
                borderColor: 'rgba(52, 152, 219, 0.4)', // Light Blue
                borderWidth: 1,
                pointRadius: 0,
                fill: false,
                tension: 0
            });
        }
    }

    // 4. Calculate Statistics
    const mean = allFinalPositions.reduce((sum, val) => sum + val, 0) / numPaths;
    const variance = allFinalPositions.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / numPaths;
    const stdDev = Math.sqrt(variance);

    // Theoretical Values
    const theoMean = 0;
    const theoVar = Math.pow(sigma, 2) * T;
    const theoStd = Math.sqrt(theoVar);

    // 5. Update UI (Stats Panel)
    const outputHTML = `
        <h4>Statistical Analysis (t = ${T})</h4>
        <strong>Parameters:</strong> dt = ${dt.toFixed(5)}, Total Paths = ${numPaths} <br><br>
        <strong>Empirical Mean:</strong> ${mean.toFixed(4)} (Expected: ${theoMean.toFixed(4)}) <br>
        <strong>Empirical Variance:</strong> ${variance.toFixed(4)} (Expected: ${theoVar.toFixed(4)}) <br>
        <strong>Empirical StdDev:</strong> ${stdDev.toFixed(4)} (Expected: ${theoStd.toFixed(4)})
    `;
    document.getElementById('statsOutput').innerHTML = outputHTML;

    // 6. Draw Line Chart (Paths)
    const ctxPath = document.getElementById('pathChart').getContext('2d');
    if (pathChartInstance) pathChartInstance.destroy();

    pathChartInstance = new Chart(ctxPath, {
        type: 'line',
        data: {
            labels: timeLabels,
            datasets: pathDatasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            plugins: {
                title: { display: true, text: `Sample Paths (First ${Math.min(numPaths, maxPathsToDraw)} Shown)` },
                legend: { display: false },
                tooltip: { enabled: false }
            },
            scales: {
                x: { title: { display: true, text: 'Time (t)' }, ticks: { maxTicksLimit: 8 } },
                y: { title: { display: true, text: 'W(t)' } }
            }
        }
    });

    // 7. Draw Histogram (Distribution of Final Positions)
    drawHistogram(allFinalPositions, theoMean, theoStd, T);
}

function drawHistogram(data, mean, std, T) {
    const ctxHist = document.getElementById('histChart').getContext('2d');
    if (histChartInstance) histChartInstance.destroy();

    // Binning Logic
    const binCount = 30;
    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = max - min;
    const step = range / binCount;
    
    const bins = new Array(binCount).fill(0);
    const labels = [];
    
    for(let i=0; i<binCount; i++) {
        labels.push( (min + (i*step) + step/2).toFixed(2) );
    }

    data.forEach(val => {
        let idx = Math.floor((val - min) / step);
        if(idx >= binCount) idx = binCount - 1;
        bins[idx]++;
    });

    // Generate Theoretical Normal Curve
    // We scale the PDF to match the histogram counts: PDF * (TotalSamples * BinWidth)
    const scaleFactor = data.length * step;
    const normalCurve = labels.map(x => {
        const xVal = parseFloat(x);
        const pdf = (1 / (std * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((xVal - mean) / std, 2));
        return pdf * scaleFactor;
    });

    histChartInstance = new Chart(ctxHist, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Frequency',
                    data: bins,
                    backgroundColor: 'rgba(230, 126, 34, 0.7)',
                    borderWidth: 1
                },
                {
                    type: 'line',
                    label: 'Theoretical Normal',
                    data: normalCurve,
                    borderColor: 'rgba(46, 204, 113, 1)',
                    borderWidth: 2,
                    tension: 0.4,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: `Distribution of W(${T})` }
            },
            scales: {
                x: { title: { display: true, text: 'Final Value' } }
            }
        }
    });
}

// Auto-run on load
window.onload = runBrownianSimulation;
</script>
