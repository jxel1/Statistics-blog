---
layout: post
title: Homework 11 - Dynamic Brownian Motion Simulation
use_math: true
date: 2025-12-01
---

<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    /* Basic styling to match the dashboard look */
    .sim-container {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        max-width: 100%;
        margin: 0 auto;
        color: #333;
    }

    /* Input Grid */
    .input-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #ddd;
    }

    .input-group label {
        display: block;
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 0.9em;
    }

    .input-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        color: #333;
    }

    /* Button */
    button#runBtn {
        width: 100%;
        padding: 12px;
        background-color: #e67e22; /* Matches the orange in your image */
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 1.1em;
        cursor: pointer;
        font-weight: bold;
        margin-bottom: 25px;
        transition: background 0.3s;
    }

    button#runBtn:hover {
        background-color: #d35400;
    }

    /* Stats Box */
    .stats-box {
        background: #2c3e50; /* Dark blue/grey background */
        color: #ecf0f1;
        padding: 20px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        margin-bottom: 25px;
        line-height: 1.6;
    }

    .stats-box h4 {
        margin-top: 0;
        color: #3498db;
        border-bottom: 1px solid #555;
        padding-bottom: 10px;
    }

    /* Charts Layout */
    .charts-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }

    .chart-wrapper {
        flex: 1;
        min-width: 300px; /* Stack on mobile */
        background: #fff;
        padding: 10px;
        border: 1px solid #eee;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
</style>

## Simulation Dashboard

Adjust the parameters below and click "Run Simulation" to generate new paths and analyze the distribution.

<div class="sim-container">

    <div class="input-grid">
        <div class="input-group">
            <label for="sim-T">1. Time Horizon (T)</label>
            <input type="number" id="sim-T" value="1" step="0.1">
        </div>
        <div class="input-group">
            <label for="sim-n">2. Time Steps (n)</label>
            <input type="number" id="sim-n" value="1000" step="10">
        </div>
        <div class="input-group">
            <label for="sim-N">3. Trajectories (simulations)</label>
            <input type="number" id="sim-N" value="500" step="10">
        </div>
        <div class="input-group">
            <label for="sim-sigma">4. Diffusion ($\sigma$)</label>
            <input type="number" id="sim-sigma" value="1" step="0.1">
        </div>
    </div>

    <button id="runBtn" onclick="runSimulation()">Run Simulation</button>

    <div class="stats-box" id="stats-output">
        Click "Run Simulation" to see results.
    </div>

    <div class="charts-row">
        <div class="chart-wrapper">
            <canvas id="pathsChart"></canvas>
        </div>
        <div class="chart-wrapper">
            <canvas id="histChart"></canvas>
        </div>
    </div>

</div>

<script>
// --- Global Chart Instances (to allow destroying them on re-run) ---
let pathsChartInstance = null;
let histChartInstance = null;

// --- Helper: Box-Muller Transform for Random Normal ---
function randn_bm() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random(); 
    while(v === 0) v = Math.random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}

// --- Main Simulation Function ---
function runSimulation() {
    // 1. Get Inputs
    const T = parseFloat(document.getElementById('sim-T').value);
    const n = parseInt(document.getElementById('sim-n').value);
    const N_paths = parseInt(document.getElementById('sim-N').value);
    const sigma = parseFloat(document.getElementById('sim-sigma').value);
    const dt = T / n;

    // 2. Run Simulations
    const allFinalPositions = [];
    const datasets = [];
    
    // We only want to DRAW a max of 50 paths to keep the chart readable/fast
    // but we calculate ALL paths for the statistics.
    const maxPathsToDraw = 50; 
    
    // Time labels for the x-axis
    const labels = [];
    // Only generate labels for a subset of points to save memory if n is huge
    // For chart.js line chart, we usually need labels for every point or it gets confused
    // Let's generate simple numeric labels
    for(let i=0; i<=n; i++) {
        // Only push label if it's manageable, else empty string
        labels.push((i * dt).toFixed(2));
    }

    for(let p=0; p < N_paths; p++) {
        let currentW = 0;
        const pathData = [0];
        
        for(let i=0; i<n; i++) {
            // dW = sigma * sqrt(dt) * Z
            const dW = sigma * Math.sqrt(dt) * randn_bm();
            currentW += dW;
            
            // Only store path data if we intend to draw this specific path
            if(p < maxPathsToDraw) {
                pathData.push(currentW);
            }
        }
        
        // Store final value for stats
        allFinalPositions.push(currentW);

        // Add to chart datasets if within limit
        if(p < maxPathsToDraw) {
            datasets.push({
                label: `Path ${p}`,
                data: pathData,
                borderColor: 'rgba(54, 162, 235, 0.4)', // Blueish
                borderWidth: 1,
                pointRadius: 0,
                fill: false,
                tension: 0
            });
        }
    }

    // 3. Calculate Statistics
    const sum = allFinalPositions.reduce((a, b) => a + b, 0);
    const mean = sum / N_paths;
    
    const variance = allFinalPositions.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / N_paths;
    const stdDev = Math.sqrt(variance);

    // Theoretical values
    const theoMean = 0;
    const theoVar = Math.pow(sigma, 2) * T;
    const theoStd = Math.sqrt(theoVar);

    // 4. Update Stats Display
    const statsHTML = `
        <h4>Statistical Analysis</h4>
        <strong>Parameters:</strong> T = ${T}, dt = ${dt.toFixed(4)}, &sigma; = ${sigma}<br>
        <br>
        <strong>Empirical Results (at time T):</strong><br>
        Mean: ${mean.toFixed(4)} (Expected: ${theoMean.toFixed(4)})<br>
        Variance: ${variance.toFixed(4)} (Expected: ${theoVar.toFixed(4)})<br>
        Std Dev: ${stdDev.toFixed(4)} (Expected: ${theoStd.toFixed(4)})
    `;
    document.getElementById('stats-output').innerHTML = statsHTML;

    // 5. Draw Path Chart
    const ctxPaths = document.getElementById('pathsChart').getContext('2d');
    if(pathsChartInstance) pathsChartInstance.destroy();

    pathsChartInstance = new Chart(ctxPaths, {
        type: 'line',
        data: {
            labels: labels, // X-axis labels
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false, // Disable animation for speed
            plugins: {
                title: { display: true, text: `Brownian Paths (Showing first ${Math.min(N_paths, maxPathsToDraw)})` },
                legend: { display: false },
                tooltip: { enabled: false } // Tooltips slow down large datasets
            },
            scales: {
                x: { title: { display: true, text: 'Time (t)' }, ticks: { maxTicksLimit: 10 } },
                y: { title: { display: true, text: 'W(t)' } }
            }
        }
    });

    // 6. Draw Histogram
    drawHistogram(allFinalPositions, theoMean, theoStd, T);
}

// --- Helper: Draw Histogram with Normal Curve Overlay ---
function drawHistogram(data, mean, std, T) {
    const ctxHist = document.getElementById('histChart').getContext('2d');
    if(histChartInstance) histChartInstance.destroy();

    // A. Bin the data
    const binCount = 30; // Number of bars
    const minVal = Math.min(...data);
    const maxVal = Math.max(...data);
    // Add small buffer to range
    const range = maxVal - minVal;
    const step = range / binCount;
    
    const bins = new Array(binCount).fill(0);
    const binLabels = [];
    
    // Create labels (center of bin)
    for(let i=0; i<binCount; i++) {
        const binCenter = minVal + (i * step) + (step/2);
        binLabels.push(binCenter.toFixed(2));
    }

    // Fill bins
    data.forEach(val => {
        let binIndex = Math.floor((val - minVal) / step);
        if(binIndex >= binCount) binIndex = binCount - 1; // Catch max value
        bins[binIndex]++;
    });

    // B. Generate Theoretical Normal Curve Points
    // We need to scale the PDF to match the count histogram
    // Scale Factor = (Total Samples * Bin Width)
    const totalSamples = data.length;
    const scaleFactor = totalSamples * step;

    const normalData = binLabels.map(x => {
        const xNum = parseFloat(x);
        const pdf = (1 / (std * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((xNum - mean) / std, 2));
        return pdf * scaleFactor;
    });

    // C. Render Chart
    histChartInstance = new Chart(ctxHist, {
        type: 'bar',
        data: {
            labels: binLabels,
            datasets: [
                {
                    label: 'Simulation Histogram',
                    data: bins,
                    backgroundColor: 'rgba(230, 126, 34, 0.6)', // Orange
                    borderColor: 'rgba(230, 126, 34, 1)',
                    borderWidth: 1,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0,
                    order: 2
                },
                {
                    type: 'line',
                    label: `Theoretical N(0, ${T})`,
                    data: normalData,
                    borderColor: 'rgba(46, 204, 113, 1)', // Green
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: false,
                    order: 1
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                title: { display: true, text: 'Distribution of Final Positions W(T)' },
                tooltip: { mode: 'index', intersect: false }
            },
            scales: {
                x: { title: { display: true, text: 'Final Position' } },
                y: { title: { display: true, text: 'Frequency' } }
            }
        }
    });
}

// Run simulation once on load
window.onload = function() {
    runSimulation();
};
</script>

### Explanation of the Code

1.  **HTML Structure:** I created a grid layout for inputs ($T$, $n$, $N$, $\sigma$) and a dedicated "Stats Box" styled similarly to your screenshot (dark background, monospaced font).
2.  **Chart.js Logic:**
    * **Line Chart (Left):** It simulates $N$ paths but, for performance reasons, I only **plot** the first 50. If you try to plot 1000 lines in a browser chart, it will lag significantly. However, the statistics are calculated using **all** 1000 (or whatever number you input) paths.
    * **Histogram (Right):** Chart.js does not have a native Histogram. I wrote a `drawHistogram` function that manually calculates bins (frequencies) from the simulation data.
    * **Theoretical Overlay:** The green line on the histogram is generated using the PDF of the Normal distribution: $f(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}$. It is scaled to match the height of the histogram bars.
3.  **Math:** The formula for the steps uses the diffusion coefficient $\sigma$:
    $$dW = \sigma \cdot \varepsilon \sqrt{dt}$$
