---
title: "Homework 8: Analogies between Bernoulli-process LLN and Combinatorics"
layout: post
date: 2025-11-12
---

# Homework 8 — Analogies and Mathematical Structure

## Problem Statement
Compare and connect the Bernoulli-trial / LLN simulation from **Homework 7** with classical combinatorial objects: binomial coefficients, Pascal's triangle, binomial expansion, the Fibonacci sequence, and related combinatorial identities. Provide mathematical explanations, show how the simulation illustrates those properties, and include runnable browser code and figures suitable for embedding in a Jekyll Markdown page.

---

## 1. Recap of the Stochastic Model
A Bernoulli process with success probability \(p\) repeated for \(n\) independent trials produces a random count of successes \(B_n \sim \text{Binomial}(n, p)\).

\[ P(B_n = k) = \binom{n}{k} p^k (1-p)^{n-k} \]

The **expected value** is \(E[B_n] = np\), and the **variance** is \(Var[B_n] = np(1-p)\). The **Law of Large Numbers** ensures \(B_n/n \to p\) as \(n \to \infty\).

In the random-walk analogy from Homework 7, each trial contributes \(+1\) if secure and \(-1\) if breached, leading to final score \(S = n - 2B_n\). Thus, the random-walk outcomes directly correspond to binomial coefficients.

---

## 2. Comparison with Homework 7

**Shared foundation:** both simulations rely on repeated Bernoulli trials.

**Different observables:** Homework 7 focused on cumulative score paths and final-score distributions. The LLN visualization emphasized convergence of relative frequencies.

**Unified principle:** both converge to deterministic limits through the LLN and approximate normality through the Central Limit Theorem.

---

## 3. Pascal’s Triangle and Binomial Coefficients

Each outcome sequence corresponds to a unique path through Pascal’s triangle. The number of paths reaching a given final score \(S = n - 2k\) equals \(\binom{n}{k}\). The triangle’s recurrence relation \(\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}\) reflects conditional decomposition by the final trial.

---

## 4. Binomial Expansion

The binomial theorem:

\[ (1 + x)^n = \sum_{k=0}^n \binom{n}{k} x^k \]

is the algebraic counterpart of the simulation’s probabilistic expansion. Substituting \(x = p/(1-p)\) yields the binomial distribution. The generating functions of Bernoulli trials encode the same coefficients that govern combinatorial structures.

---

## 5. Fibonacci Sequence and Diagonal Sums

Fibonacci numbers appear as shallow diagonals in Pascal’s triangle:

\[ F_n = \sum_{k=0}^{\lfloor (n-1)/2 \rfloor} \binom{n-k-1}{k} \]

This reflects constrained combinatorial counting — the number of binary strings with no consecutive failures, for example. These diagonal sums highlight how recursive sequences arise naturally from binomial structures.

---

## 6. Combinatorial Identities and Probabilistic Meaning

- **Vandermonde’s Identity:** splitting \(n\) trials into two groups mirrors combining independent Bernoulli blocks.
- **Symmetry:** \(\binom{n}{k} = \binom{n}{n-k}\) reflects complementarity between success and failure outcomes.
- **Normalization:** \(\sum_k \binom{n}{k} p^k (1-p)^{n-k} = 1\) confirms total probability.

---

## 7. Visual Demonstration and Simulation

The following HTML fragment runs directly inside a Markdown post on GitHub Pages. It simulates both the random-walk trajectories and the final-score distribution, and prints Pascal’s triangle with Fibonacci diagonal values.

```html
<div style="margin-bottom:10px;">
  <label>Weeks n:</label><input id="n" type="number" value="20" min="1" max="500" style="width:60px;">
  <label>Attackers per week m:</label><input id="m" type="number" value="3" min="1" max="100" style="width:60px;">
  <label>Per-attacker p:</label><input id="p" type="number" value="0.05" min="0" max="1" step="0.01" style="width:60px;">
  <label>Simulations:</label><input id="Nsim" type="number" value="20000" min="100" max="2000000" step="100" style="width:100px;">
  <label>Paths shown:</label><input id="showPaths" type="number" value="12" min="1" max="200" style="width:60px;">
  <button id="go">Run</button>
</div>

<div id="traj" style="height:360px;"></div>
<div id="dist" style="height:420px; margin-top:30px;"></div>
<pre id="pascal" style="font-family:monospace; white-space:pre; margin-top:20px;"></pre>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
(function(){
  function binom(n,k){
    if(k<0||k>n) return 0;
    k = Math.min(k, n-k);
    let res=1;
    for(let i=1;i<=k;i++) res = res*(n-(k-i))/i;
    return res;
  }

  function theoPMF(n,m,p){
    const q = 1-Math.pow(1-p,m);
    const arr=[];
    for(let k=0;k<=n;k++){
      const score = n-2*k;
      const prob = binom(n,k)*Math.pow(q,k)*Math.pow(1-q,n-k);
      arr.push({score,prob});
    }
    return arr;
  }

  function simulate(n,m,p,Nsim,showPaths){
    const q = 1-Math.pow(1-p,m);
    const counts = new Map();
    const trajectories = [];
    for(let i=0;i<Nsim;i++){
      let s=0;
      const path=[];
      for(let t=0;t<n;t++){
        s += (Math.random()<q)? -1 : 1;
        if(i<showPaths) path.push(s);
      }
      if(i<showPaths) trajectories.push(path);
      counts.set(s,(counts.get(s)||0)+1);
    }
    const dist=[];
    for(let s=-n;s<=n;s+=2) dist.push({score:s, freq: (counts.get(s)||0)/Nsim});
    return {trajectories, dist};
  }

  function gaussianApprox(x, mean, varx){
    const sd = Math.sqrt(varx);
    return (1/(sd*Math.sqrt(2*Math.PI))) * Math.exp(-0.5*Math.pow((x-mean)/sd,2));
  }

  function makePascalStrip(rows){
    const tri = [];
    for(let r=0;r<rows;r++){
      const row=[];
      for(let k=0;k<=r;k++) row.push(binom(r,k));
      tri.push(row);
    }
    let s = '';
    for(let r=0;r<rows;r++){
      s += tri[r].map(x=>String(x).padStart(4,' ')).join(' ') + '\n';
    }
    s += '\nFibonacci diagonal sums:\n';
    for(let n=1;n<=10;n++){
      let fibsum=0;
      for(let k=0;k<=Math.floor((n-1)/2);k++) fibsum += binom(n-k-1,k);
      s += `F(${n}) = ${fibsum}\n`;
    }
    return s;
  }

  function render(){
    const n = +document.getElementById('n').value;
    const m = +document.getElementById('m').value;
    const p = +document.getElementById('p').value;
    const Nsim = +document.getElementById('Nsim').value;
    const showPaths = +document.getElementById('showPaths').value;

    const sim = simulate(n,m,p,Nsim,showPaths);
    const theo = theoPMF(n,m,p);

    const traces = sim.trajectories.map(path=>({
      x: path.map((_,i)=>i+1),
      y: path,
      mode: 'lines',
      line: {width:1},
      hoverinfo: 'none'
    }));
    Plotly.newPlot('traj', traces, {title:'Cumulative-score trajectories', xaxis:{title:'Week'}, yaxis:{title:'Cumulative score'}});

    const xSim = sim.dist.map(d=>d.score);
    const ySim = sim.dist.map(d=>d.freq);
    const xTheo = theo.map(d=>d.score);
    const yTheo = theo.map(d=>d.prob);

    const simTrace = {x:xSim, y:ySim, type:'bar', name:'Simulated', marker:{color:'rgba(30,144,255,0.8)'}};
    const theoTrace = {x:xTheo, y:yTheo, mode:'markers', name:'Theoretical binomial', marker:{color:'red', size:8, symbol:'circle-open'}};

    const q = 1-Math.pow(1-p,m);
    const mean = n - 2*(n*q);
    const varS = 4*n*q*(1-q);
    const xGauss = [];
    const yGauss = [];
    for(let s=-n;s<=n;s+=2){
      xGauss.push(s);
      yGauss.push( gaussianApprox(s, mean, varS)*2 );
    }
    const gaussTrace = {x:xGauss, y:yGauss, mode:'lines', name:'Gaussian approx', line:{color:'green', dash:'dash'}};

    Plotly.newPlot('dist', [simTrace, theoTrace, gaussTrace], {title:`Final-score distribution (n=${n}, m=${m}, p=${p})`, xaxis:{title:'Total score'}, yaxis:{title:'Probability'}});

    document.getElementById('pascal').innerText = makePascalStrip(Math.min(12,n+2));
  }

  document.getElementById('go').onclick = render;
  render();
})();
</script>
```

