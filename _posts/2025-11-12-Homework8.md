---
title: "Homework 8: Analogies Between Random Walks and Bernoulli Processes"
layout: post
date: 2025-11-12
use_math: true
---

<script>
MathJax = {
  tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

## Analogies Between Server Security Simulation and Bernoulli Process (Homework 7)

This project extends the ideas explored in **Homework 7**, where we modeled a **Bernoulli process** to illustrate the **Law of Large Numbers (LLN)**.  
Both models are random in nature, built on repeated independent Bernoulli trials, and their results reveal deep mathematical relationships through **binomial coefficients**, **Pascal’s triangle**, and **combinatorial symmetries**.

---

### Conceptual Parallels

1. **Bernoulli Trials**

   In both simulations, each trial can be seen as a Bernoulli variable:
   - For Homework 7: success with probability $p$.
   - For this random-walk model: security breach with probability $p$ (transformed to ±1 increments).

   The cumulative score over $n$ trials becomes the sum of independent variables:

   $$
   S_n = \sum_{i=1}^n X_i, \quad X_i \in \{+1, -1\}
   $$

   where $\mathbb{P}(X_i = +1) = 1 - q$ and $\mathbb{P}(X_i = -1) = q$, with $q = 1 - (1 - p)^m$.

---

2. **Binomial Structure**

   The probability of observing exactly $k$ breaches in $n$ weeks follows the binomial law:

   $$
   \mathbb{P}(K = k) = \binom{n}{k} q^k (1 - q)^{n - k}
   $$

   Since the total score is $S = n - 2k$, the score distribution mirrors a reflected binomial process.

   This shows that the cumulative behavior of the server’s security is mathematically identical to a **random walk with biased steps**.

---

3. **Pascal’s Triangle and Binomial Expansion**

   The recursive nature of binomial coefficients:

   $$
   \binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}
   $$

   directly parallels the evolution of the random walk — every new step can come from one of two previous outcomes (up or down).  
   This recurrence defines Pascal’s triangle, which encodes all possible outcomes of such walks.

   Binomial expansion reinforces this relationship:

   $$
   (p + q)^n = \sum_{k=0}^n \binom{n}{k} p^k q^{n-k}
   $$

   Each term corresponds to the probability of a distinct sequence of secure/breached weeks.

---

4. **Fibonacci and Combinatorics**

   In constrained random walks (e.g., paths that never go below zero), the counting of valid paths connects to Fibonacci numbers.  
   For instance, the number of possible walks of length $n$ avoiding negative cumulative scores grows as $F_{n+2}$, where $F_n$ is the Fibonacci sequence.

---

### Mathematical and Probabilistic Connection

- Both processes approach **Gaussian distributions** for large $n$ (Central Limit Theorem).  
- The **mean** and **variance** of the total score follow:

  $$
  \mathbb{E}[S_n] = n(1 - 2q), \quad \text{Var}(S_n) = 4nq(1 - q)
  $$

  showing a direct link between random walk dynamics and binomial moments.

---

### Interactive Simulation

Below is a browser-based visualization comparing random-walk trajectories and final-score distribution, replicating the mathematical structure described above.

```html
<div style="margin-bottom:10px;">
  <label>Weeks (n): </label><input id="weeks" type="number" value="20" min="1" max="200" step="1" style="width:60px;margin-right:15px;">
  <label>Attackers (m): </label><input id="attackers" type="number" value="3" min="1" max="100" step="1" style="width:60px;margin-right:15px;">
  <label>p: </label><input id="prob" type="number" value="0.05" min="0" max="1" step="0.01" style="width:60px;margin-right:15px;">
  <label>Simulations: </label><input id="sims" type="number" value="10000" min="100" max="1000000" step="100" style="width:80px;margin-right:15px;">
  <label>Paths: </label><input id="paths" type="number" value="8" min="1" max="50" step="1" style="width:60px;margin-right:15px;">
  <button id="runSim">Run</button>
</div>

<div id="rw-trajectories" style="height:400px;"></div>
<div style="margin-top:40px;">
  <h3>Distribution of Final Scores</h3>
  <div id="rw-dist" style="height:400px;"></div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
(function() {
  function binomial(n, k) {
    if (k < 0 || k > n) return 0;
    let res = 1;
    for (let i = 1; i <= k; i++) res *= (n - (k - i)) / i;
    return res;
  }

  function theoreticalDistribution(n, m, p) {
    const q = 1 - Math.pow(1 - p, m);
    const dist = [];
    for (let k = 0; k <= n; k++) {
      const score = n - 2 * k;
      const prob = binomial(n, k) * Math.pow(q, k) * Math.pow(1 - q, n - k);
      dist.push({ score, prob });
    }
    return dist;
  }

  function simulatePaths(n, m, p, Nsim, Npaths) {
    const q = 1 - Math.pow(1 - p, m);
    const counts = new Map();
    const trajectories = [];
    for (let i = 0; i < Nsim; i++) {
      let score = 0;
      const path = [];
      for (let t = 0; t < n; t++) {
        score += (Math.random() < q) ? -1 : 1;
        if (i < Npaths) path.push(score);
      }
      counts.set(score, (counts.get(score) || 0) + 1);
      if (i < Npaths) trajectories.push(path);
    }
    const dist = [];
    for (let s = -n; s <= n; s += 2)
      dist.push({ score: s, freq: (counts.get(s) || 0) / Nsim });
    return { trajectories, dist };
  }

  function plotTrajectories(trajs) {
    const traces = trajs.map(path => ({
      x: Array.from({length: path.length}, (_, i) => i + 1),
      y: path,
      mode: "lines",
      line: { width: 1 },
      hoverinfo: "none"
    }));
    const layout = {
      title: "Cumulative Score Trajectories",
      xaxis: { title: "Week" },
      yaxis: { title: "Cumulative Score" },
      plot_bgcolor: "white",
      paper_bgcolor: "white",
      font: { color: "black" }
    };
    Plotly.newPlot("rw-trajectories", traces, layout);
  }

  function plotDistribution(sim, theo) {
    const simTrace = {
      x: sim.map(d => d.score),
      y: sim.map(d => d.freq),
      type: "bar",
      name: "Simulated Frequencies",
      marker: { color: "rgba(30,144,255,0.7)" }
    };

    const theoTrace = {
      x: theo.map(d => d.score),
      y: theo.map(d => d.prob),
      mode: "markers",
      marker: { color: "red", size: 8, symbol: "circle-open" },
      line: { color: "red", width: 2 },
      name: "Theoretical Binomial"
    };

    const layout = {
      xaxis: { title: "Total Score (S)" },
      yaxis: { title: "Probability" },
      barmode: "overlay",
      plot_bgcolor: "white",
      paper_bgcolor: "white",
      font: { color: "black" }
    };

    Plotly.newPlot("rw-dist", [simTrace, theoTrace], layout);
  }

  function run() {
    const n = +document.getElementById("weeks").value;
    const m = +document.getElementById("attackers").value;
    const p = +document.getElementById("prob").value;
    const Nsim = +document.getElementById("sims").value;
    const Npaths = +document.getElementById("paths").value;

    const { trajectories, dist } = simulatePaths(n, m, p, Nsim, Npaths);
    plotTrajectories(trajectories);
    plotDistribution(dist, theoreticalDistribution(n, m, p));
  }

  document.getElementById("runSim").onclick = run;
  run();
})();
</script>
