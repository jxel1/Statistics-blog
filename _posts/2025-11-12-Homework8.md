---
title: "Homework 8: Combinatorial Analogies — Pascal, Fibonacci, and Bernoulli Processes"
layout: post
date: 2025-11-12
use_math: true
---

{% raw %}
<script>
MathJax = {
  tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

## Homework 8: Analogies Between Combinatorial Structures and Random Walks
This assignment explores the **relationship between random processes and combinatorial mathematics**, extending the ideas of Homework 7 (Bernoulli process and LLN).
We connect **Pascal’s triangle**, **Fibonacci growth**, and **binomial combinatorics** to probabilistic simulation.

---

### 1. Pascal’s Triangle — Binomial Structure Visualization
The binomial coefficient is defined as:
$$
\binom{n}{k} = \frac{n!}{k!(n-k)!}
$$
Each row of **Pascal’s Triangle** corresponds to coefficients of $(a+b)^n$ and also to the probabilities of outcomes in $n$ Bernoulli trials.

<div>
  <label>Rows (n): </label><input id="rows" type="number" value="10" min="1" max="20" step="1" style="width:60px;margin-right:15px;">
  <button id="genPascal">Generate Pascal’s Triangle</button>
</div>
<div id="pascal-triangle" style="height:500px;margin-top:20px;"></div>

<script>
(function() {
  function pascal(n) {
    const triangle = [];
    for (let r = 0; r < n; r++) {
      const row = [1];
      for (let c = 1; c < r; c++) row[c] = triangle[r-1][c-1] + triangle[r-1][c];
      if (r > 0) row.push(1);
      triangle.push(row);
    }
    return triangle;
  }
  function plotPascal(triangle) {
    const data = [];
    for (let r = 0; r < triangle.length; r++) {
      const y = Array(triangle[r].length).fill(r);
      const x = triangle[r].map((_, i) => i - triangle[r].length / 2);
      const z = triangle[r];
      data.push({
        x, y, z,
        mode: "markers+text",
        type: "scatter3d",
        text: z.map(v => v.toString()),
        textposition: "top center",
        marker: { size: 5, color: z, colorscale: "Viridis" },
        showlegend: false
      });
    }
    const layout = {
      title: "Pascal’s Triangle — Binomial Coefficients",
      scene: { xaxis: { title: "k" }, yaxis: { title: "n" }, zaxis: { title: "Value" } },
      margin: { l: 0, r: 0, b: 0, t: 40 }
    };
    Plotly.newPlot("pascal-triangle", data, layout);
  }
  function updatePascal() {
    const n = +document.getElementById("rows").value;
    plotPascal(pascal(n));
  }
  document.getElementById("genPascal").onclick = updatePascal;
  updatePascal();
})();
</script>

---

### 2. Fibonacci Sequence and Combinatorial Growth
The Fibonacci numbers appear in constrained combinatorial processes — e.g., counting random walks that **never drop below zero** or tiling problems.
$$
F_0 = 0, \quad F_1 = 1, \quad F_{n} = F_{n-1} + F_{n-2}
$$
We can visualize Fibonacci growth both numerically and approximately via the **Golden Ratio**:
$$
\phi = \frac{1 + \sqrt{5}}{2}
$$

<div>
  <label>Terms: </label><input id="fib-n" type="number" value="15" min="2" max="30" step="1" style="width:60px;margin-right:15px;">
  <button id="genFib">Generate Fibonacci Sequence</button>
</div>
<div id="fib-seq" style="height:400px;margin-top:20px;"></div>

<script>
(function() {
  function fibonacci(n) {
    const seq = [0, 1];
    for (let i = 2; i < n; i++) seq.push(seq[i-1] + seq[i-2]);
    return seq;
  }
  function plotFib(n) {
    const seq = fibonacci(n);
    const approx = seq.map((_, i) => Math.pow((1 + Math.sqrt(5)) / 2, i) / Math.sqrt(5));
    const trace1 = { x: seq.map((_, i) => i), y: seq, type: "scatter", mode: "lines+markers", name: "Fibonacci" };
    const trace2 = { x: seq.map((_, i) => i), y: approx, type: "scatter", mode: "lines", name: "Golden Ratio Approx." };
    const layout = {
      title: "Fibonacci Sequence and Golden Ratio Approximation",
      xaxis: { title: "n" },
      yaxis: { title: "F(n)" }
    };
    Plotly.newPlot("fib-seq", [trace1, trace2], layout);
  }
  document.getElementById("genFib").onclick = () => {
    const n = +document.getElementById("fib-n").value;
    plotFib(n);
  };
  plotFib(15);
})();
</script>

---

### 3. Interactive Bernoulli Simulation (Combinatorial Perspective)
We simulate a **Bernoulli process** and visualize the **distribution of total successes** compared with the theoretical **binomial probabilities**, which are directly encoded by Pascal’s triangle.
$$
P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
$$

<div>
  <label>n: </label><input id="bern-n" type="number" value="20" min="1" max="200" step="1" style="width:60px;margin-right:10px;">
  <label>p: </label><input id="bern-p" type="number" value="0.5" min="0" max="1" step="0.01" style="width:60px;margin-right:10px;">
  <label>Simulations: </label><input id="bern-sim" type="number" value="10000" min="100" max="500000" step="100" style="width:80px;margin-right:10px;">
  <button id="bern-run">Run Simulation</button>
</div>
<div id="bern-dist" style="height:450px;margin-top:20px;"></div>

<script>
(function() {
  function binomial(n, k) {
    if (k < 0 || k > n) return 0;
    let res = 1;
    for (let i = 1; i <= k; i++) res *= (n - (k - i)) / i;
    return res;
  }
  function theoreticalBinomial(n, p) {
    const dist = [];
    for (let k = 0; k <= n; k++) {
      const prob = binomial(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
      dist.push({ k, prob });
    }
    return dist;
  }
  function simulateBernoulli(n, p, sims) {
    const counts = new Array(n + 1).fill(0);
    for (let s = 0; s < sims; s++) {
      let success = 0;
      for (let i = 0; i < n; i++) if (Math.random() < p) success++;
      counts[success]++;
    }
    return counts.map((c, k) => ({ k, freq: c / sims }));
  }
  function plotBernoulli(n, p, sims) {
    const sim = simulateBernoulli(n, p, sims);
    const theo = theoreticalBinomial(n, p);
    const simTrace = {
      x: sim.map(d => d.k),
      y: sim.map(d => d.freq),
      type: "bar",
      name: "Simulated"
    };
    const theoTrace = {
      x: theo.map(d => d.k),
      y: theo.map(d => d.prob),
      type: "scatter",
      mode: "lines+markers",
      name: "Theoretical"
    };
    const layout = {
      title: `Bernoulli Process — n=${n}, p=${p}`,
      xaxis: { title: "Number of Successes (k)" },
      yaxis: { title: "Probability" }
    };
    Plotly.newPlot("bern-dist", [simTrace, theoTrace], layout);
  }
  document.getElementById("bern-run").onclick = () => {
    const n = +document.getElementById("bern-n").value;
    const p = +document.getElementById("bern-p").value;
    const sims = +document.getElementById("bern-sim").value;
    plotBernoulli(n, p, sims);
  };
  plotBernoulli(20, 0.5, 10000);
})();
</script>

---

### Mathematical Summary
All three structures — **Pascal’s triangle**, **Fibonacci growth**, and the **Bernoulli process** — emerge from the same combinatorial logic:
- Pascal’s triangle encodes all possible combinations.
- Fibonacci counts restricted combinations (paths avoiding overlap or negatives).
- The Bernoulli process transforms combinations into probabilities via the binomial distribution.
Their mathematical backbone is the binomial identity:
$$
(a+b)^n = \sum_{k=0}^{n} \binom{n}{k} a^k b^{n-k}
$$
which governs probability, growth, and symmetry in discrete systems.

{% endraw %}
